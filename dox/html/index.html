<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>n-DimensionalDisplayInterface(NDDI): n-Dimensional Display Interface (NDDI): Pixel Bridge Use Case</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>n-Dimensional Display Interface (NDDI): Pixel Bridge Use Case </h1>  </div>
</div>
<div class="contents">
<dl class="author"><dt><b>Authors:</b></dt><dd>Dave Estes &lt;<a href="mailto:cdestes@email.unc.edu">cdestes@email.unc.edu</a>&gt;</dd></dl>
<h2><a class="anchor" id="overview"></a>
Overview</h2>
<p>The n-Dimensional Display Interface (NDDI) is a new approach to getting pixels to a display. Typically displays use a frame buffer for receiving pixels to be displayed. That frame buffer must be updated at a frequency equal to the desired refresh rate.</p>
<p>Modern displays implement features such as double buffering to prevent to prevent partial updates or even higher order functions to fill or blit. In each case, the entire framebuffer would not need to be updated on every cycle.</p>
<p>NDDI builds on these concepts in a simple-to-implement hardware solution.</p>
<h2><a class="anchor" id="frameVolume"></a>
Pixel Storage: Frame Volume</h2>
<p>The n-Dimensional aspect of NDDI refers to the Frame Volume. Instead of organizing a display device's pixels into a two-dimensional frame buffer and updating all of those pixels for every frame, a multi-dimensional frame volume is created. The frame volume also contains pixels, but there is a highly-configurable mapping that takes place, instead of the fixed mapping used with a traditional frame buffer.</p>
<h2><a class="anchor" id="coefficientPlane"></a>
Mapping: Coefficient Plane</h2>
<p>The mapping is configured through the use of a coefficient plane. The coefficient plane, is a is a two dimensional array of coefficient matrices. The dimensions of the coefficient plane match the dimensions of the viewable area, which is typically the size of the actual display. The size of the coefficient matrices are dependant on the frame volume and the input vector size. the number of columns in each coefficient matrix matches the size of the input vector. The number of rows matches the number of dimensions in the frame volume.</p>
<h2><a class="anchor" id="inputVector"></a>
Driving the Display: Input Vector</h2>
<p>The display output is driven by the input vector. The first two values in the input correspond to to a pixel location on the display as well as the corresponding coefficient matrix in the coefficient plane. These first two values are not driven by the nddi client, but are used by the display to refresh itself. If the input vector is larger than two, then the nddi client can use them to drive particular mappings. As an example, a third value can be used as a clock tick that will help animated the frames of a sprite.</p>
<h2><a class="anchor" id="pixelBridge"></a>
Pixel Brige Use Case</h2>
<p>Pixel Brige is the first use case, used to study the viability of NDDI. The goal of Pixel Bridge is is to take a recording computing session and display it on an NDDI display. FFMPEG is leveraged to playback VMNC recordings created with VMWare. VMNC is an RFB stream encapsulated in an AVI containter. RFB is the same protocol used by VNC. Using FFMPEG also allows the playback of another other video format supported by FFMPEG.</p>
<p>The NDDI display was implemented in such a way that it returns a framebuffer that is rendered into an OpenGL window. The parallel calculations were sped up with OpenMP. OpenCL was used as an alternative, but the latest status is that it's suffering a lot of rendering errors.</p>
<p>The NDDI display is configured as a simple frame buffer, as a flat tiled display, and as a cached tiled display. The <a class="el" href="class_flat_tiler.html" title="This tiler will split provided frames into tiles and update the NDDI display.">FlatTiler</a> and <a class="el" href="class_cached_tiler.html" title="This tiler will split provided frames into tiles and update the NDDI display.">CachedTiler</a> classes are responsible for taking a decoded frame and tiling it. They then update the attached NDDI.</p>
<p>Additionally the Pixel Brige can calculate the estimated cost of the same number duration of video renderer at 60 Hz. This serves as a lower bounds, which all three configurations will outperform. For the upper boundary, Pixel Bridge can return the number of bytes (four per pixel) changed. This would be the cost associated if "Perfect Pixel Latching" without any addressing information was possible. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Dec 13 2010 19:27:00 for n-DimensionalDisplayInterface(NDDI) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
