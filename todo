##############
###  TODO  ###
##############

+---------+
| General |
----------+

x Create new nDDI APIs to update the scaler for each coefficient matrix.
x Correctly initialize the coefficient planes with 0 scalers (PixelBridgeMain, FlatTiler, and CachedTiler).
x Update GlNddiDisplay rendering to use multiple coefficient planes.
x Update coefficent blending mode to actually use the new and official multiple coefficient support.
x Implement DctTiler.
  x Initialize Frame Volume with pre-rendered basis functions
  x Initialize Coefficient Planes
  x Debug: Make a dummy tile updater that just renders 64 macroblocks as the basis functions themselves.
  x Implement proper updater
  x Figure out the proper sign-extending and clamping strategy for the accumulators in ComputePixel().
  x Implement a FillScalerTiled that will accept an array of scalers and fill each tile in the plane with the provided scaler
x Review and fix ALL transmission cost calculations. Pay attention to the p in the (x, y, p) locations for coefficient planes.
x Get PSNR working again.
x Add cost model tracking for scaler writes...and read?
x For DCT, initializing the coefficient plane is KILLING me. Fix it by:
  x Redesign it to fill the a coefficient matrix to an 8x8x192 area.
  x Then kill in the k values for each of the 192 planes.
x Update the coefficient plane to update the cost model correctly and efficiently with OpenMP. There are descrepencies when between OpenMP and NO_OMP.
x Update cost model for scaler access, either by just registering it ot the coefficient plane or by some more specific component.
x Determine if it's necessary to narrow some data values like scalers and coordinates (for transmission).

x Re-run all of the original experiments including the new video-based tilers.
  x Run them all headless
  x Run the lossy modes for PSNR
    NOTE: Waited on RAM even for the SW mode because I only had 32 MB.


+--------------+
| Optimization |
+--------------+

x Speed up DCT
  x Modify headless display to do a light-weight simulation.
  x Turn OpenMP back on after fixing the slowdown

- Optimize Coefficient Planes data layout
  x Analyze fb, flat, cache, and dct in terms of data reads and writes in order to characterize each.
  x Run perf to get a baseline of cache misses for fb, flat, cache, and dct.
  ? Should I continue to internally store scalers as Scaler structs with the unused alpha channel?
  x Re-arrange coefficient planes, arranging coefficient matrices by stacks and then scalars as stacks per pixel
    NOTE: This worked well for coefficient matrices but not for the scalers. See top of CoefficientPlanes.h
  - If necessary, update NDimensionalDisplayInterface::FillScalerTileStack to use regular array of Scalars and not a vector
  - Implement CoefficientPlane::fillScalarTileStack and directly call it from the BaseNddiDisplay::fillScalarTileStack
  - Implement CoefficientPlane::setScalarStack which is used in CoefficientPlane::fillScalarTileStack


+----------+
| Blending |
+----------+

- Revisit the Blending Experiments
  x Get Temporal Blending working
  x Get FrameVolume Blending working again
  - Devise some experiments for blending, perhaps a HUD on top of video.


+--------+
| OpenCL |
+--------+

- Update CL implementation
  x Remove #errors when using OpenCL in the DCT and IT tilers.
  x Update the CL variants of the display elements to support the narrowed data structures.
  x Add the ClCoefficientPlanes support for multiple coefficient planes
  x Implement reduced window size for testing
  x Update fillCoefficient.cl to use start coordinates with a plane component
  - Test:
    - ClCoefficientPlanes.PutCoefficientMatrix()
    - ClCoefficientPlanes.FillCoefficientMatrix()
    - ClCoefficientPlanes.FillCoefficient()
    - ClCoefficientPlanes.FillScaler()
  - Change computePixel.cl to blend the planes. Test blending mode before dct.
  - Add the ClCoefficientPlanes support for scalers
    - Implement FillScalerTileStack API for ClNddiDisplay.

- Implement FillScalerTiles API for ClNddiDisplay.


+-------+
| Video |
+-------+

- Video Paper
X 1. Only resend changed coefficients. See TODO in DctTiler.cpp and final bullet below
x 2. Define a list (3-5) of Coefficient Priority Schemes which will be used to hit predefined data budgets.
x 3. Implement an overall measure of motion per frame (against previous frame).
  4. Explore and find a set (3-5) of Multiscale configurations to use.
  5. Implement Priority schemes to meet configurable fixed data budgets.
    x Add --dctbudget command line option that specifies the budget in bytes per frame.
    x Add --dectplanes command line option
    x For each scale, consider that it is allowed a particular percentage of the overall budget. So
      if a scale takes 4 of 63 planes, then it is allowed 4/63 = 6.35% of the overall data budget.
      The exception is if a scale is configured with only one plane. In such a case, then it is excluded
      from budget constraints.
    - Schemes:
      x SnapToZero with Delta - Any coefficient within a delta of zero is snapped to zero.
      x Trim with Delta - Any coefficient within a delta of the previous frame is not updated.
      x SnapToZero with Plane - Any coefficient in the least significant planes is zeroed.
      x Trim with Plane - Each stack will be trimmed to this number of planes.
      - Revise the estimation for the schemes with planes to be more accurate
    x Output CSV Data for each frame with frame number, transmission cost, and PSNR.
  6. Do experiments
    - Graph each video, showing plots of PSNR over time of each X configurations by Y priority schemes for Z data budgets.
      Think line graphs with PSNR or Y axis and time on X axis.
    - Graph aggregate data of PSNR to motion measurement. Think histogram with PSNR on Y axis and motion buckets on X axis.
      Can also be points with trend line as a way of plotting key combinations of configiration, priority scheme, and data budget.
  7. Write

- Add multi-scale DCT support
  x Change DCT to support to only resend middle portion of changed scalers. See TODO in DctTiler.cpp.
  x Mode A: Fixed set of super-macro-block levels and planes per each level
    x Add configuration mechanism to set the scales and number of planes each
    x Set up the Coefficient Planes based on the multiscale configuration
    x For a super-macro-block
      x Blend groups of pixels to create 8x8 macroblock (bilinear interpolation)
      x Perform DCT to build most significant coefficients
      x Perform iDCT to get the output super-macro-block and subtract that from the source video to get the new current frame.
    x Repeat at the lower levels until we're operating on normal macroblocks
  x When filling coefficients, don't fill the first n set of most significant coefficients if they're zero.

- Implement YuvTiler
  - For a 16x16 macroblock, build 8x8 blocks: Y0, Y1, Y2, Y3, U, and V.
  - Then arrange them into two 8x8 RBGA blocks, where blocks are mapped as such:
    - Block 0: R holds Y0, G holds Y1, B holds U
    - Block 1: R holds Y2, G holds Y3, B holds V
  - Configure coefficient planes so that they map the correct pixels from those blocks and perform colorspace conversion using
    the formulas. This might be hard, since I have to use the RGB channels of the scalers for this math and they only work to
    produce their perspective colors.
      Y' = 0.299 R + 0.587 G + 0.114 B
      R = Y' + 1.14 V
      G = Y' - 0.295 U - 0.518 V
      B = Y' + 2.044 U
  - May have to drop the 32 bit pixel values from the frame volume and make it pure byte memory.


+-------------+
| Future Work |
+-------------+

- Consider breaking down the COEFFICIENT_PLANE_COMPONENT into coefficient accesses and scaler accesses.
- Add nDDI command caching and playback mode. Will avoid the video decode and tiler calculations.
- Narrow pixel size to three channels
  - Look for all of the places where we do offsets like with sizeof(unsigned int) and replace with pixelSize_;
- Modify FFMPEG's MJPEG decoder to and have it create DCT coefficients for the DctTiler automatically.